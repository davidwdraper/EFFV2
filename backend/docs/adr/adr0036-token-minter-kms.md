adr0036-token-minter-kms
# ADR-0036 — Token Minter using GCP KMS Sign

## Context

The NowVibin backend requires secure, verifiable tokens for **service-to-service (S2S)** communication.  
Local key storage or PEM files are unacceptable due to operational and security risk.  
We will use **Google Cloud KMS** for all JWT signing operations, with a deterministic Key ID (KID)  
so public keys can be served via JWKS (ADR‑0035).

Current need:  
- Gateway and worker services must mint signed S2S JWTs.
- Signatures must be verifiable by JWKS consumers.
- Signing logic must be isolated and reusable.

Constraints:
- **No local secrets or PEMs.**
- **No fallbacks or defaults.**
- **Fail-fast** if any configuration or signing call fails.
- **Deterministic KID** (matches JWKS entries).

---

## Decision

Create a shared `Minter` class (in `backend/services/shared/src/security/Minter.ts`)  
that constructs JWTs signed by a pluggable `IJwtSigner` implementation.  
The first implementation will use Google Cloud KMS (`KmsJwtSigner`).

### Overview

Each service that needs to produce a signed JWT will:

1. Inject a `KmsJwtSigner` instance (configured via `MinterEnv.assert()`).
2. Call `await minter.mint({ ttlSec, aud, sub?, iss? })`.
3. Receive `{ jwt, header, claims, issuedAt, expiresAt }`.

JWTs will follow standard registered claims (`iat`, `nbf`, `exp`, `aud`, `iss`, `sub`, `jti`)  
plus any optional extension claims.

The KMS key and algorithm are specified entirely by environment variables;  
no in‑code assumptions are permitted.

---

## Consequences

### Positive

- **No local key exposure:** All signing occurs in Google KMS.
- **Deterministic KID:** Derived from KMS path, matches JWKS endpoint.
- **Consistent S2S auth:** Gateway and services share a uniform token minting process.
- **Extensible:** Future signers (e.g., HSM, mock, local) can implement `IJwtSigner`.

### Negative

- **Requires GCP KMS permissions.** Services must be deployed with credentials granting `cloudkms.cryptoKeyVersions.useToSign`.
- **Adds KMS latency** (~5–20 ms typical per sign).
- **No offline mode:** tokens cannot be minted without GCP access.
- **Failure semantics:** If KMS returns an error or latency exceeds timeout, `Minter` throws synchronously and no token is returned. Retry logic belongs to callers (e.g., `TokenProvider`).

---

## Implementation Notes

### 1. Environment Validation

`MinterEnv.ts` uses Zod to validate:

```
KMS_PROJECT_ID
KMS_LOCATION_ID
KMS_KEY_RING_ID
KMS_KEY_ID
KMS_KEY_VERSION
KMS_JWT_ALG
NV_ISSUER
```

All are **required**, no defaults. Missing any → service fails fast.

### 2. KMS Signer (`KmsJwtSigner.ts`)

Implements:

```ts
export interface IJwtSigner {
  alg(): string;
  kid(): string;
  sign(header: object, payload: object): Promise<string>;
}
```

- Uses `@google-cloud/kms`.
- Computes deterministic KID as:  
  `kms:<project>:<location>:<ring>:<key>:v<version>`.
- Returns compact JWT string (`header.payload.signature`).
- Returned header must include `alg` and `kid` fields matching JWKS entries exactly; verification depends on equality.

### 3. Minter (`Minter.ts`)

```ts
export type MintOptions = {
  ttlSec: number;
  aud: string;
  sub?: string;
  iss?: string;
  nbfSkewSec?: number;
  type?: "s2s" | "client" | "internal";
  extra?: Record<string, unknown>;
};
```

- Computes `iat`, `nbf`, and `exp` based on injected clock.
- `jti` must be a UUIDv4 generated by the shared ID util to guarantee uniqueness and audit traceability.
- Signs via injected signer.
- Returns `{ jwt, header, claims, issuedAt, expiresAt }`.
- Logs entry/exit with `kid`, `alg`, `aud`, `ttlSec`.

### 4. secureS2S Middleware

Will verify JWTs via JWKS (ADR‑0035) and enforce:

- Allowed `aud` from `S2S_REQUIRED_AUD`.
- Allowed `iss` from `S2S_REQUIRED_ISS`.

### 5. Future Integrations

- `SvcClient` will inject `Minter` and attach `Authorization: Bearer <jwt>`.
- Gateway will strip client Authorization and re‑mint its own.

---

## Alternatives Considered

1. **Local PEM keys:**  
   Rejected — violates secret management policy; impossible to rotate safely.

2. **Symmetric signing (HMAC):**  
   Rejected — would expose shared secret; no verifiable public JWKS.

3. **Central Auth service minting all tokens:**  
   Rejected — adds latency and coupling; violates service autonomy.

4. **KMS via intermediate helper API:**  
   Rejected — reintroduces local secrets and network indirection.

---

## References

- **ADR‑0035 — JWKS Service for Public Keys**
- **RFC 7519 — JSON Web Token (JWT)**
- **RFC 7515 — JSON Web Signature (JWS)**
- **SOP: docs/architecture/backend/SOP.md (Reduced, Clean)**
