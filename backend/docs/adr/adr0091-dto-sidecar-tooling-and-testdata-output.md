adr0091-dto-sidecar-tooling-and-testdata-output

## Status
Draft / Proposed

## Context
ADR-0090 defines a runtime Field Definition DSL that DTOs can export (e.g., `UserFields`) without changing canonical DTO JSON or DTO validation behavior.

NV tests need deterministic “happy” payloads for DTOs. Tests then mutate those payloads downstream (missing fields, duplicates, invalid chars, etc.). Uniqueness constraints (e.g., email/phone) must avoid DB duplicates in tests, but build-time tools cannot guarantee DB state.

This ADR defines the **sidecar tool** that consumes the DSL, its functions, and the artifacts it produces.

## Decision
Create a DTO sidecar tool that:
1) loads DTO modules and their exported `Fields`
2) generates **happy-only** canonical JSON payloads (data-only; no meta)
3) emits a `.tdata.ts` sidecar module adjacent to the DTO
4) provides optional field hint metadata needed for downstream mutation (uniquify, missing required, invalid alpha, etc.)

### 1) Inputs
For a given DTO:
- DTO module path (or service root + dtoType key)
- exported `Fields` constant (as defined in ADR-0090)
- optional tool configuration (seed, output directory rules)

### 2) Outputs (.tdata sidecar)
The tool generates a TypeScript module with a `.tdata.ts` extension (checked into repo) that exports a wrapper object/class with:

- `getJson(): object` — returns “happy” canonical JSON (data only)
- `getHints(): object` (optional) — returns minimal field hints for downstream mutation
- no scenario methods in v1 (happy-only; alternate cases mutated downstream)

**Happy-only rule (v1):** sidecar stores a single happy payload. All test variants are generated by test-runner mutation utilities.

#### Example shape (illustrative)
```ts
export class UserDtoTdata {
  public static getJson(): unknown { return { ...happy data... }; }
  public static getHints(): unknown { return { fields: { email: { unique:true, ... } } }; }
}
```

### 3) Deterministic generation rules
The tool must generate values deterministically so test fixtures are stable.

#### Required vs optional
- `required: true` → always include
- `required: false` → include iff `presentByDefault !== false` (default include)

#### Strings
- Default string values may be “letter junk” (nobody sees it) but must honor:
  - `minLen/maxLen`
  - `alpha` and `case` if set

#### Numbers
- Choose a value within constraints:
  - if `min/max` present, choose `min` (or a midpoint) deterministically
  - otherwise choose a stable small positive integer (e.g., 1)

#### Literal / enum
- literal: emit the literal
- enum: emit the first enum value (deterministic)

### 4) Uniqueness rail (test-time, not build-time)
`unique:true` means: tests must avoid DB duplicates by mutating these fields at runtime.

- Build-time sidecars **do not** attempt DB uniqueness.
- Test-runner must run a `uniquify()` mutation step using a per-scenario seed (requestId / scenarioId guid).

#### Unique strategy (v1)
- seed: scenario GUID or requestId
- derive: hash(seed + dtoType + fieldPath)
- encode: letters-only `[A-Za-z]`
- length: 12 letters (constraint-aware; truncate/extend to fit minLen/maxLen)
- apply `case` rules if set

This produces compact, deterministic, collision-resistant values suitable for “DB flushed often” development flows.

### 5) Downstream mutation responsibilities (test-runner)
Sidecar tool does not generate scenario variants. Test-runner (or shared test library) performs mutations such as:

- `missingRequired(field)` — delete one required field
- `duplicateByContent()` — re-use exact same happy JSON without uniquify
- `invalidAlpha(field)` — inject a non-letter char into an `alpha:true` field
- `overflowMaxLen(field)` — extend string to exceed `maxLen` by 1
- `uniquify(seed)` — mutate only fields marked `unique:true`

### 6) Safety: meta never emitted in test JSON
- `.tdata` `getJson()` returns canonical DTO JSON only.
- Tool may emit `getHints()` but must not emit `{ data, meta }` envelopes in happy JSON.

### 7) Verification pass (optional but recommended)
Tool may optionally load the DTO class and validate the generated happy JSON by calling:
- `Dto.fromBody(happyJson)` (preferred) or `fromJson(...)`

If verification fails, tool must fail-fast with actionable output:
- DTO name
- field path
- generated value
- violated constraint (if known)

## Consequences

### Positive
- Stable, boring sidecars that don’t drift into test frameworks.
- Tests remain explicit; fixtures remain simple.
- Uniqueness is enforced where it can actually be enforced: at runtime with a scenario seed.
- Incremental adoption: DTOs without `Fields` simply have no sidecar generation.

### Negative / Risks
- Tool and DTO validation can disagree if DSL constraints are incomplete. Verification pass mitigates this.
- Some teams may want richer scenario libraries; v1 intentionally avoids that complexity.

## Implementation Notes
- Sidecar file naming: align with DTO file name and place beside it, e.g.:
  - `user.dto.ts`
  - `user.dto.tdata.ts`
- Sidecar must be importable by test-runner without requiring tool execution at runtime.
- Keep outputs deterministic to reduce flaky diffs.

## Alternatives Considered
- Generating multiple scenarios in sidecars (rejected for v1: muddier artifacts and harder to reason about).
- Querying DB at build time for uniqueness (rejected: env coupling and slow/fragile tooling).
- Embedding meta envelope in sidecar JSON (rejected: increases risk of leakage).

## References
- ADR-0089: DTO Field DSL with Meta Envelope (umbrella direction)
- ADR-0090: DTO Field DSL Design and Non-Breaking Integration
